<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>『钻』研iOS 之 深入理解NSRunLoop | DeJohn&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="差不多2年前，我对NSRunLoop有过应用层面上的理解，现在我们通过苹果开源在github上的swift-corelibs-foundation来深入了解下苹果是如何实现的这个CFRunLoop(NSRunLoop是对CFRunLoop的封装)。当然，还是2年前的那句话：NSRunLoop其英文释义一样，是运行一个无限循环，她是跟线程一起存在的。在主线程中NSRunLoop是默认启动的；在多线程">
<meta property="og:type" content="article">
<meta property="og:title" content="『钻』研iOS 之 深入理解NSRunLoop">
<meta property="og:url" content="http://yoursite.com/2017/02/12/「钻」研iOS 之深入理解NSRunLoop/index.html">
<meta property="og:site_name" content="DeJohn's Blog">
<meta property="og:description" content="差不多2年前，我对NSRunLoop有过应用层面上的理解，现在我们通过苹果开源在github上的swift-corelibs-foundation来深入了解下苹果是如何实现的这个CFRunLoop(NSRunLoop是对CFRunLoop的封装)。当然，还是2年前的那句话：NSRunLoop其英文释义一样，是运行一个无限循环，她是跟线程一起存在的。在主线程中NSRunLoop是默认启动的；在多线程">
<meta property="og:image" content="http://ipa-download.qiniudn.com/AAA622AD-DBF3-4D35-9086-333DDF9FE9AE.png">
<meta property="og:image" content="http://ipa-download.qiniudn.com/0FFEFFA1-F7A0-4802-B54F-19C00A66EE27.png">
<meta property="og:image" content="http://ipa-download.qiniudn.com/873A4049-C316-44A9-8BE7-14CE03035923.png">
<meta property="og:image" content="http://ipa-download.qiniudn.com/1F89CF6C-237F-46FC-8E16-34ECDE208F20.png">
<meta property="og:updated_time" content="2017-02-12T02:32:21.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="『钻』研iOS 之 深入理解NSRunLoop">
<meta name="twitter:description" content="差不多2年前，我对NSRunLoop有过应用层面上的理解，现在我们通过苹果开源在github上的swift-corelibs-foundation来深入了解下苹果是如何实现的这个CFRunLoop(NSRunLoop是对CFRunLoop的封装)。当然，还是2年前的那句话：NSRunLoop其英文释义一样，是运行一个无限循环，她是跟线程一起存在的。在主线程中NSRunLoop是默认启动的；在多线程">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img src="https://avatars1.githubusercontent.com/u/2617618?v=3&amp;s=460" class="js-avatar" style="width: 100%;height: 100%;opacity: 1;">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">DeJohn Dong</a></h1>
		</hgroup>

		
		<p class="header-subtitle">董佳的博客</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/openboy2012" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/p/1005051492121455/home" title="weibo">weibo</a>
					        
								<a class="zhihu" target="_blank" href="http://www.zhihu.com/people/diao-shu-79" title="zhihu">zhihu</a>
					        
								<a class="mail" target="_blank" href="Mailto:dongjia_9251@126.com" title="mail">mail</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/ARC-MRC/" style="font-size: 10px;">ARC & MRC</a> <a href="/tags/Block/" style="font-size: 10px;">Block</a> <a href="/tags/C-混编/" style="font-size: 10px;">C++混编</a> <a href="/tags/DeJohn-Style/" style="font-size: 12.5px;">DeJohn Style</a> <a href="/tags/Objective-C/" style="font-size: 15px;">Objective-C</a> <a href="/tags/RunLoop/" style="font-size: 10px;">RunLoop</a> <a href="/tags/iOS事件响应/" style="font-size: 10px;">iOS事件响应</a> <a href="/tags/iOS基础/" style="font-size: 15px;">iOS基础</a> <a href="/tags/iOS多线程/" style="font-size: 15px;">iOS多线程</a> <a href="/tags/iOS学习笔记/" style="font-size: 20px;">iOS学习笔记</a> <a href="/tags/iOS开发/" style="font-size: 17.5px;">iOS开发</a> <a href="/tags/iOS消息循环/" style="font-size: 10px;">iOS消息循环</a> <a href="/tags/内存管理/" style="font-size: 12.5px;">内存管理</a> <a href="/tags/开源代码/" style="font-size: 17.5px;">开源代码</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">钻钻她爹，有强迫症的iOS高级开发工程师...</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">DeJohn Dong</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="https://avatars1.githubusercontent.com/u/2617618?v=3&amp;s=460" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">DeJohn Dong</h1>
			</hgroup>
			
			<p class="header-subtitle">董佳的博客</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/openboy2012" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/p/1005051492121455/home" title="weibo">weibo</a>
			        
						<a class="zhihu" target="_blank" href="http://www.zhihu.com/people/diao-shu-79" title="zhihu">zhihu</a>
			        
						<a class="mail" target="_blank" href="Mailto:dongjia_9251@126.com" title="mail">mail</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap"><article id="post-「钻」研iOS 之深入理解NSRunLoop" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/02/12/「钻」研iOS 之深入理解NSRunLoop/" class="article-date">
  	<time datetime="2017-02-12T02:32:21.000Z" itemprop="datePublished">2017-02-12</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      『钻』研iOS 之 深入理解NSRunLoop
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Objective-C/">Objective-C</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/RunLoop/">RunLoop</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS事件响应/">iOS事件响应</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS基础/">iOS基础</a></li></ul>
	</div>

        

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>差不多2年前，我对<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSRunLoop_Class/index.html#//apple_ref/doc/uid/TP40003725" target="_blank" rel="external">NSRunLoop</a>有过应用层面上的理解，现在我们通过苹果开源在github上的<a href="https://github.com/apple/swift-corelibs-foundation" target="_blank" rel="external">swift-corelibs-foundation</a>来深入了解下苹果是如何实现的这个CFRunLoop(NSRunLoop是对CFRunLoop的封装)。<br>当然，还是2年前的那句话：<br><code>NSRunLoop</code>其英文释义一样，是运行一个无限循环，她是跟线程一起存在的。在主线程中NSRunLoop是默认启动的；在多线程中NSRunLoop默认不是启动的，需要开发者手动运行才能启动。 </p>
<h2 id="RunLoop的概念：">RunLoop的概念：</h2><p>RunLoop本质上是一个<a href="https://en.wikipedia.org/wiki/Event_loop" target="_blank" rel="external">Event Loop</a>，实现的是一个<code>do-while</code>循环，主要用来处理事件消息。<br><a id="more"></a><br>苹果设计的高明之处：是进入do-while循环之后不会导致死循环，因为<code>mach_port</code>的存在，会让这个RunLoop在某个事件处睡眠，事件循环就暂停，再在需要的时候通过<code>mach_port</code>唤醒RunLoop，事件循环就会继续处理。</p>
<h2 id="CFRunLoop_&amp;_CFRunLoopMode"><strong>CFRunLoop &amp; </strong>CFRunLoopMode</h2><p>源码中的结构体定义如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __<span class="built_in">CFRunLoop</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    pthread_mutex_t _lock;	<span class="comment">//对象锁，线程保护</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _commonModes;    <span class="comment">//这个Set主要CommonModes类型的名字，能保证不重复名字的mode</span></span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _commonModeItems; <span class="comment">//commonModes里可以插入不同Mode Items（可包含Source、Timer和Observer类型）</span></span><br><span class="line">    <span class="built_in">CFRunLoopModeRef</span> _currentMode; <span class="comment">//当前执行的mode</span></span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _modes; <span class="comment">//runLoop的modes，每次执行循环只能执行其中的一个</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> __<span class="built_in">CFRunLoopMode</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    pthread_mutex_t _lock;	<span class="comment">/* must have the run loop locked before locking this */</span> <span class="comment">//对象锁，保证线程安全</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _sources0; <span class="comment">//source0类型的CFRunLoopSource的set</span></span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _sources1; <span class="comment">//source1类型的CFRunLoopSource的set</span></span><br><span class="line">    <span class="built_in">CFMutableArrayRef</span> _observers; <span class="comment">//observer数组</span></span><br><span class="line">    <span class="built_in">CFMutableArrayRef</span> _timers; <span class="comment">//timer数组</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>由结构体定义可知<code>__CFRunLoop</code>内部有_commonModes、_commonModeItems和_modes2个SET集合：</p>
<ul>
<li><code>commonModes</code>（SET类型）只存储Mode的别名；</li>
<li><code>commonModeItems</code>（SET类型）存储的<code>__CFRunLoopMode</code>的结构体；<br>  <code>__CFRunLoopMode</code>内部定义了这个4个集合类的实例：<ul>
<li>source0（SET类型）：用来存储<code>__CFRunLoopSource</code>的结构体对象；</li>
<li>source1（SET类型）：用来存储<code>__CFRunLoopSource</code>的结构体对象，该对象在runLoop睡眠时被唤醒；</li>
<li>timer（Array类型）：用来存储<code>__CFRunLoopTimer</code>的结构体对象，   </li>
<li>observer（Array类型）：用来存储<code>__CFRunLoopObserver</code>的结构体对象；   </li>
</ul>
</li>
<li><code>modes</code>：runLoop执行的mode，每次循环只能执行其中的一个Mode。</li>
</ul>
<p>说明一个<code>__CFRunLoop</code>中可以插入多个Mode，每个Mode又可以包含多个source事件、多个timer实例和多个观察者(observer)对象，Source、Timer和Observer统称Mode Item。</p>
<h4 id="至于source为何选用set类型，而timer与observer选用的array类型？">至于source为何选用set类型，而timer与observer选用的array类型？</h4><p>猜测：<code>SET集合</code>既能保证数据的唯一性（hash值比较），又能快速索引（比如NSObject cancel延时事件，需要快速准确得找到cancel的source这种场景）。</p>
<h2 id="CFRunLoopSourceRef_&amp;_CFRunLoopTimerRef_&amp;_CFRunLoopObserverRef">CFRunLoopSourceRef &amp; CFRunLoopTimerRef &amp; CFRunLoopObserverRef</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __<span class="built_in">CFRunLoopSource</span> &#123;</span><br><span class="line">    <span class="built_in">CFRuntimeBase</span> _base;</span><br><span class="line">    uint32_t _bits;</span><br><span class="line">    pthread_mutex_t _lock;</span><br><span class="line">    <span class="built_in">CFIndex</span> _order; <span class="comment">/* immutable */</span></span><br><span class="line">    <span class="built_in">CFMutableBagRef</span> _runLoops;</span><br><span class="line">    <span class="keyword">union</span> &#123; <span class="comment">//联合体能保证在同一个时间内不会同时使用version0和version1,2个数据结构体中只有一个会存在，符合runLoop的设计</span></span><br><span class="line">        <span class="built_in">CFRunLoopSourceContext</span> version0; <span class="comment">/* immutable, except invalidation */</span></span><br><span class="line">        <span class="built_in">CFRunLoopSourceContext1</span> version1; <span class="comment">/* immutable, except invalidation */</span></span><br><span class="line">    &#125; _context;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="built_in">CFIndex</span> version;</span><br><span class="line">    <span class="keyword">void</span> * info;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span> *(*retain)(<span class="keyword">const</span> <span class="keyword">void</span> *info);</span><br><span class="line">    <span class="keyword">void</span> (*release)(<span class="keyword">const</span> <span class="keyword">void</span> *info);</span><br><span class="line">    <span class="built_in">CFStringRef</span> (*copyDescription)(<span class="keyword">const</span> <span class="keyword">void</span> *info);</span><br><span class="line">    Boolean (*equal)(<span class="keyword">const</span> <span class="keyword">void</span> *info1, <span class="keyword">const</span> <span class="keyword">void</span> *info2);</span><br><span class="line">    <span class="built_in">CFHashCode</span> (*hash)(<span class="keyword">const</span> <span class="keyword">void</span> *info);</span><br><span class="line">    <span class="comment">//定时处理，适用`performSelector:withObject:afterDelay:`</span></span><br><span class="line">    <span class="keyword">void</span> (*schedule)(<span class="keyword">void</span> *info, <span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFRunLoopMode</span> mode);</span><br><span class="line">    <span class="comment">//取消处理，适用`cancelPreviousPerformRequestsWithTarget:selector:object:` </span></span><br><span class="line">    <span class="keyword">void</span> (*cancel)(<span class="keyword">void</span> *info, <span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFRunLoopMode</span> mode);</span><br><span class="line">    <span class="keyword">void</span> (*perform)(<span class="keyword">void</span> *info);</span><br><span class="line">&#125; <span class="built_in">CFRunLoopSourceContext</span>; <span class="comment">//iOS的performSelector系列方法会用这个Context存储函数指针，并且可以取消</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="built_in">CFIndex</span> version;</span><br><span class="line">    <span class="keyword">void</span> * info;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span> *(*retain)(<span class="keyword">const</span> <span class="keyword">void</span> *info);</span><br><span class="line">    <span class="keyword">void</span> (*release)(<span class="keyword">const</span> <span class="keyword">void</span> *info);</span><br><span class="line">    <span class="built_in">CFStringRef</span> (*copyDescription)(<span class="keyword">const</span> <span class="keyword">void</span> *info);</span><br><span class="line">    Boolean (*equal)(<span class="keyword">const</span> <span class="keyword">void</span> *info1, <span class="keyword">const</span> <span class="keyword">void</span> *info2);</span><br><span class="line">    <span class="built_in">CFHashCode</span> (*hash)(<span class="keyword">const</span> <span class="keyword">void</span> *info);</span><br><span class="line">    mach_port_t (*getPort)(<span class="keyword">void</span> *info);</span><br><span class="line">    <span class="keyword">void</span> * (*perform)(<span class="keyword">void</span> *msg, <span class="built_in">CFIndex</span> size, <span class="built_in">CFAllocatorRef</span> allocator, <span class="keyword">void</span> *info);</span><br><span class="line">&#125; <span class="built_in">CFRunLoopSourceContext1</span>;</span><br></pre></td></tr></table></figure>
<p><code>__CFRunLoopSource</code>是事件产生的地方，共在2种类型：<code>Source0</code>和<code>Source1</code>，struct内部通过一个union保证同一个Source对象不会同时包含version0和version1; </p>
<ul>
<li><code>Source0</code>只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 <code>CFRunLoopSourceSignal(rlms)</code>方法将这个Source标记为待处理，然后手动调用<code>CFRunLoopWakeUp(rl)</code>方法来唤醒RunLoop，让其处理这个事件。</li>
<li><code>Source1</code>包含了一个<code>mach_port</code>和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种类型的Source能主动唤醒RunLoop的线程。<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __<span class="built_in">CFRunLoopTimer</span> &#123;</span><br><span class="line">    <span class="built_in">CFRuntimeBase</span> _base;</span><br><span class="line">    uint16_t _bits;</span><br><span class="line">    pthread_mutex_t _lock;</span><br><span class="line">    <span class="built_in">CFRunLoopRef</span> _runLoop;</span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _rlModes;</span><br><span class="line">    <span class="built_in">CFAbsoluteTime</span> _nextFireDate;</span><br><span class="line">    <span class="built_in">CFTimeInterval</span> _interval;		<span class="comment">/* immutable */</span></span><br><span class="line">    <span class="built_in">CFTimeInterval</span> _tolerance;          <span class="comment">/* mutable */</span></span><br><span class="line">    uint64_t _fireTSR;			<span class="comment">/* TSR units */</span></span><br><span class="line">    <span class="built_in">CFIndex</span> _order;			<span class="comment">/* immutable */</span></span><br><span class="line">    <span class="built_in">CFRunLoopTimerCallBack</span> _callout;	<span class="comment">/* immutable */</span></span><br><span class="line">    <span class="built_in">CFRunLoopTimerContext</span> _context;	<span class="comment">/* immutable, except invalidation */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><code>__CFRunLoopTimer</code>：是基于时间的触发器，它和<code>NSTimer</code>是toll-free bridged的，可以混用。其包含一个时间长度和一个回调（函数指针）。当其加入到RunLoop时，RunLoop会注册对应的时间点，当时间点到达时，RunLoop会被唤醒以执行那个回调。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __<span class="built_in">CFRunLoopObserver</span> &#123;</span><br><span class="line">    <span class="built_in">CFRuntimeBase</span> _base;</span><br><span class="line">    pthread_mutex_t _lock;</span><br><span class="line">    <span class="built_in">CFRunLoopRef</span> _runLoop;</span><br><span class="line">    <span class="built_in">CFIndex</span> _rlCount;</span><br><span class="line">    <span class="built_in">CFOptionFlags</span> _activities;		<span class="comment">/* immutable */</span></span><br><span class="line">    <span class="built_in">CFIndex</span> _order;			<span class="comment">/* immutable */</span></span><br><span class="line">    <span class="built_in">CFRunLoopObserverCallBack</span> _callout;	<span class="comment">/* immutable */</span></span><br><span class="line">    <span class="built_in">CFRunLoopObserverContext</span> _context;	<span class="comment">/* immutable, except invalidation */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>__CFRunLoopObserver</code>：是观察者，每个Observer都包含了一个回调（函数指针），当 RunLoop的状态发生变化时，观察者就能通过回调接受到这个变化。可以观测的时间点有以下几个：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">CF_OPTIONS</span>(<span class="built_in">CFOptionFlags</span>, <span class="built_in">CFRunLoopActivity</span>) &#123;</span><br><span class="line">    k<span class="built_in">CFRunLoopEntry</span>         = (<span class="number">1</span>UL &lt;&lt; <span class="number">0</span>), <span class="comment">// 即将进入Loop</span></span><br><span class="line">    k<span class="built_in">CFRunLoopBeforeTimers</span>  = (<span class="number">1</span>UL &lt;&lt; <span class="number">1</span>), <span class="comment">// 即将处理 Timer</span></span><br><span class="line">    k<span class="built_in">CFRunLoopBeforeSources</span> = (<span class="number">1</span>UL &lt;&lt; <span class="number">2</span>), <span class="comment">// 即将处理 Source</span></span><br><span class="line">    k<span class="built_in">CFRunLoopBeforeWaiting</span> = (<span class="number">1</span>UL &lt;&lt; <span class="number">5</span>), <span class="comment">// 即将进入休眠</span></span><br><span class="line">    k<span class="built_in">CFRunLoopAfterWaiting</span>  = (<span class="number">1</span>UL &lt;&lt; <span class="number">6</span>), <span class="comment">// 刚从休眠中唤醒</span></span><br><span class="line">    k<span class="built_in">CFRunLoopExit</span>          = (<span class="number">1</span>UL &lt;&lt; <span class="number">7</span>), <span class="comment">// 即将退出Loop</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="RunLoop的设计">RunLoop的设计</h2><p>CFRunLoop的设计是一个循环处理多个类型的事件处理（Timers，Source、Observer等）模型。<br>工作流程如下图：<br><img src="http://ipa-download.qiniudn.com/AAA622AD-DBF3-4D35-9086-333DDF9FE9AE.png" width="647"></p>
<p>RunLoop中虽然包含了多个Mode，但一次循环只能执行其中一个Mode，如果要切换Mode，必须等上一次的循环结束。</p>
<p>苹果公开提供的Mode有两个：kCFRunLoopDefaultMode（NSDefaultRunLoopMode）和 UITrackingRunLoopMode，你可以用这两个<code>ModeName</code>来操作其对应的Mode。</p>
<p><code>注意</code>：这里有个概念叫<code>CommonModes</code>：一个Mode可以将自己标记为”Common”属性（通过将其 ModeName添加到RunLoop的”commonModes”中）。每当RunLoop的内容发生变化时，RunLoop都会自动将_commonModeItems里的Source/Observer/Timer同步到具有”Common”标记的所有Mode里。我们可以通过<code>NSRunLoopCommonModes</code>关键字操作CommonModeItems，这个也是苹果开放的API。</p>
<p>我们可以通过<code>addTimer:forMode:</code>方法把NSTimer（NSTimer默认是在NSRunLoopDefaultMode里）加载到CommonModeItems里，保证NSTimer的触发在UITrackingRunLoopMode里也能触发。</p>
<h2 id="RunLoop核心方法">RunLoop核心方法</h2><p>源码中的核心方法整理如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="built_in">CFRunLoopRun</span>(<span class="keyword">void</span>) &#123;	<span class="comment">/* DOES CALLOUT */</span></span><br><span class="line">    int32_t result;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        result = <span class="built_in">CFRunLoopRunSpecific</span>(<span class="built_in">CFRunLoopGetCurrent</span>(), k<span class="built_in">CFRunLoopDefaultMode</span>, <span class="number">1.0e10</span>, <span class="literal">false</span>);</span><br><span class="line">        CHECK_FOR_FORK();</span><br><span class="line">    &#125; <span class="keyword">while</span> (k<span class="built_in">CFRunLoopRunStopped</span> != result &amp;&amp; k<span class="built_in">CFRunLoopRunFinished</span> != result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SInt32 <span class="built_in">CFRunLoopRunSpecific</span>(<span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFStringRef</span> modeName, <span class="built_in">CFTimeInterval</span> seconds, Boolean returnAfterSourceHandled) &#123;     <span class="comment">/* DOES CALLOUT */</span></span><br><span class="line">    CHECK_FOR_FORK();</span><br><span class="line">    <span class="keyword">if</span> (modeName == <span class="literal">NULL</span> || modeName == k<span class="built_in">CFRunLoopCommonModes</span> || <span class="built_in">CFEqual</span>(modeName, k<span class="built_in">CFRunLoopCommonModes</span>)) &#123; <span class="comment">//如果运行到了CurrentMode是CommonModes，RunLoop就退出了。</span></span><br><span class="line">        <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">        <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">            <span class="built_in">CFLog</span>(k<span class="built_in">CFLogLevelError</span>, <span class="built_in">CFSTR</span>(<span class="string">"invalid mode '%@' provided to CFRunLoopRunSpecific - break on _CFRunLoopError_RunCalledWithInvalidMode to debug. This message will only appear once per execution."</span>), modeName);</span><br><span class="line">            _<span class="built_in">CFRunLoopError_RunCalledWithInvalidMode</span>();</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> k<span class="built_in">CFRunLoopRunFinished</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (__<span class="built_in">CFRunLoopIsDeallocating</span>(rl))</span><br><span class="line">        <span class="keyword">return</span> k<span class="built_in">CFRunLoopRunFinished</span>;</span><br><span class="line">    </span><br><span class="line">    __<span class="built_in">CFRunLoopLock</span>(rl);</span><br><span class="line">    <span class="built_in">CFRunLoopModeRef</span> currentMode = __<span class="built_in">CFRunLoopFindMode</span>(rl, modeName, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == currentMode || __<span class="built_in">CFRunLoopModeIsEmpty</span>(rl, currentMode, rl-&gt;_currentMode))</span><br><span class="line">    &#123;</span><br><span class="line">        Boolean did = <span class="literal">false</span>; <span class="comment">//这里的did是没写完么?永远是false</span></span><br><span class="line">        <span class="keyword">if</span> (currentMode)</span><br><span class="line">            __<span class="built_in">CFRunLoopModeUnlock</span>(currentMode); <span class="comment">//这里返回的CFRunLoopMode是加锁的，所以在这里要进行一次解锁</span></span><br><span class="line">        __<span class="built_in">CFRunLoopUnlock</span>(rl);</span><br><span class="line">        <span class="keyword">return</span> did ? k<span class="built_in">CFRunLoopRunHandledSource</span> : k<span class="built_in">CFRunLoopRunFinished</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">volatile</span> _per_run_data *previousPerRun = __<span class="built_in">CFRunLoopPushPerRunData</span>(rl);</span><br><span class="line">    <span class="built_in">CFRunLoopModeRef</span> previousMode = rl-&gt;_currentMode;</span><br><span class="line">    rl-&gt;_currentMode = currentMode;</span><br><span class="line">    int32_t result = k<span class="built_in">CFRunLoopRunFinished</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (currentMode-&gt;_observerMask &amp; k<span class="built_in">CFRunLoopEntry</span> )</span><br><span class="line">        __<span class="built_in">CFRunLoopDoObservers</span>(rl, currentMode, k<span class="built_in">CFRunLoopEntry</span>);</span><br><span class="line">    result = __<span class="built_in">CFRunLoopRun</span>(rl, currentMode, seconds, returnAfterSourceHandled, previousMode); <span class="comment">//runLoop循环处理方法开始</span></span><br><span class="line">    <span class="keyword">if</span> (currentMode-&gt;_observerMask &amp; k<span class="built_in">CFRunLoopExit</span> )</span><br><span class="line">        __<span class="built_in">CFRunLoopDoObservers</span>(rl, currentMode, k<span class="built_in">CFRunLoopExit</span>);</span><br><span class="line">    </span><br><span class="line">    __<span class="built_in">CFRunLoopModeUnlock</span>(currentMode);</span><br><span class="line">    __<span class="built_in">CFRunLoopPopPerRunData</span>(rl, previousPerRun);</span><br><span class="line">    rl-&gt;_currentMode = previousMode;</span><br><span class="line">    __<span class="built_in">CFRunLoopUnlock</span>(rl);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* rl, rlm are locked on entrance and exit */</span></span><br><span class="line"><span class="comment">//这个方法相关长，精简出重要代码</span></span><br><span class="line"><span class="keyword">static</span> int32_t __<span class="built_in">CFRunLoopRun</span>(<span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFRunLoopModeRef</span> rlm, <span class="built_in">CFTimeInterval</span> seconds, Boolean stopAfterHandle, <span class="built_in">CFRunLoopModeRef</span> previousMode) &#123;</span><br><span class="line">   ...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">         __<span class="built_in">CFRunLoopUnsetIgnoreWakeUps</span>(rl);</span><br><span class="line">        <span class="comment">//通知Observers，处理Timers</span></span><br><span class="line">        <span class="keyword">if</span> (rlm-&gt;_observerMask &amp; k<span class="built_in">CFRunLoopBeforeTimers</span>) __<span class="built_in">CFRunLoopDoObservers</span>(rl, rlm, k<span class="built_in">CFRunLoopBeforeTimers</span>);</span><br><span class="line">        <span class="comment">//通知Observers，处理Sources</span></span><br><span class="line">        <span class="keyword">if</span> (rlm-&gt;_observerMask &amp; k<span class="built_in">CFRunLoopBeforeSources</span>) __<span class="built_in">CFRunLoopDoObservers</span>(rl, rlm, k<span class="built_in">CFRunLoopBeforeSources</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//处理加入的Block</span></span><br><span class="line">        __<span class="built_in">CFRunLoopDoBlocks</span>(rl, rlm);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//处理Source0的事件</span></span><br><span class="line">        Boolean sourceHandledThisLoop = __<span class="built_in">CFRunLoopDoSources0</span>(rl, rlm, stopAfterHandle);</span><br><span class="line">        <span class="keyword">if</span> (sourceHandledThisLoop) &#123;</span><br><span class="line">            __<span class="built_in">CFRunLoopDoBlocks</span>(rl, rlm);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Boolean poll = sourceHandledThisLoop || (<span class="number">0</span>ULL == timeout_context-&gt;termTSR);</span><br><span class="line">        </span><br><span class="line">        didDispatchPortLastTime = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//通知Observers 即将睡眠</span></span><br><span class="line">        <span class="keyword">if</span> (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; k<span class="built_in">CFRunLoopBeforeWaiting</span>)) __<span class="built_in">CFRunLoopDoObservers</span>(rl, rlm, k<span class="built_in">CFRunLoopBeforeWaiting</span>);</span><br><span class="line">        __<span class="built_in">CFRunLoopSetSleeping</span>(rl);</span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">        __<span class="built_in">CFRunLoopSetIgnoreWakeUps</span>(rl);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// user callouts now OK again</span></span><br><span class="line">        __<span class="built_in">CFRunLoopUnsetSleeping</span>(rl);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//通知Observer 睡眠唤醒</span></span><br><span class="line">        <span class="keyword">if</span> (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; k<span class="built_in">CFRunLoopAfterWaiting</span>)) __<span class="built_in">CFRunLoopDoObservers</span>(rl, rlm, k<span class="built_in">CFRunLoopAfterWaiting</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">CFRUNLOOP_WAKEUP_FOR_SOURCE</span>();</span><br><span class="line">        <span class="comment">// Despite the name, this works for windows handles as well</span></span><br><span class="line">        <span class="built_in">CFRunLoopSourceRef</span> rls = __<span class="built_in">CFRunLoopModeFindSourceForMachPort</span>(rl, rlm, livePort);</span><br><span class="line">            <span class="keyword">if</span> (rls) &#123;</span><br><span class="line">                mach_msg_header_t *reply = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="comment">//处理Source1的事件</span></span><br><span class="line">                sourceHandledThisLoop = __<span class="built_in">CFRunLoopDoSource1</span>(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply) || sourceHandledThisLoop; </span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">NULL</span> != reply) &#123;</span><br><span class="line">                    (<span class="keyword">void</span>)mach_msg(reply, MACH_SEND_MSG, reply-&gt;msgh_size, <span class="number">0</span>, MACH_PORT_NULL, <span class="number">0</span>, MACH_PORT_NULL);</span><br><span class="line">                    <span class="built_in">CFAllocatorDeallocate</span>(k<span class="built_in">CFAllocatorSystemDefault</span>, reply);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         ...</span><br><span class="line">         </span><br><span class="line">        __<span class="built_in">CFRunLoopDoBlocks</span>(rl, rlm); <span class="comment">//睡眠方法唤醒以后处理加入了的Block事件</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class="line">            retVal = k<span class="built_in">CFRunLoopRunHandledSource</span>; <span class="comment">//</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeout_context-&gt;termTSR &lt; mach_absolute_time()) &#123;</span><br><span class="line">            retVal = k<span class="built_in">CFRunLoopRunTimedOut</span>; <span class="comment">//判断是否超时</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__<span class="built_in">CFRunLoopIsStopped</span>(rl)) &#123;</span><br><span class="line">            __<span class="built_in">CFRunLoopUnsetStopped</span>(rl);</span><br><span class="line">            retVal = k<span class="built_in">CFRunLoopRunStopped</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rlm-&gt;_stopped) &#123;</span><br><span class="line">            rlm-&gt;_stopped = <span class="literal">false</span>;</span><br><span class="line">            retVal = k<span class="built_in">CFRunLoopRunStopped</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__<span class="built_in">CFRunLoopModeIsEmpty</span>(rl, rlm, previousMode)) &#123;</span><br><span class="line">            retVal = k<span class="built_in">CFRunLoopRunFinished</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span> == retVal);</span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line"><span class="preprocessor">##线程安全</span></span><br><span class="line"><span class="built_in">CFRunLoop</span>是线程安全的，<span class="built_in">CFRunLopp</span>是纯C的API封装。从源代码定义的各个结构体对象中都会包含pthread_mutex的成员变量。</span><br><span class="line">pthread_mutex被实例成了`递归锁`，递归锁能保证在同一个线程里被多次调用不会造成锁等待的情况，但在多线程中能保证数据同步而存在锁等待的效果。</span><br><span class="line">```c++</span><br><span class="line"><span class="built_in">CF_INLINE</span> <span class="keyword">void</span> __<span class="built_in">CFRunLoopLockInit</span>(pthread_mutex_t *lock) &#123;</span><br><span class="line">    pthread_mutexattr_t mattr;</span><br><span class="line">    pthread_mutexattr_init(&amp;mattr);</span><br><span class="line">    pthread_mutexattr_settype(&amp;mattr, PTHREAD_MUTEX_RECURSIVE); <span class="comment">//初始化成递归锁</span></span><br><span class="line">    int32_t mret = pthread_mutex_init(lock, &amp;mattr);</span><br><span class="line">    pthread_mutexattr_destroy(&amp;mattr);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != mret) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="RunLoop实现的功能">RunLoop实现的功能</h2><p><code>广告</code>：更多代码<a href="https://github.com/openboy2012/DDCategory" target="_blank" rel="external">demo</a>可以进入我的<a href="https://github.com/openboy2012/DDCategory" target="_blank" rel="external">github</a>进行下载查看运行结果，基本上每行关键代码都有详细的注释。本文中出现的代码都在这个项目下面，请结合项目代码阅读本文，效果更佳。</p>
<h3 id="事件响应_&amp;_手势识别_&amp;_AutoReleasePool_&amp;_UI更新">事件响应 &amp; 手势识别 &amp; AutoReleasePool &amp; UI更新</h3><p>当我们启动一个app的时候，点击暂停线程我们会看到这样一个堆栈关系：<br><img src="http://ipa-download.qiniudn.com/0FFEFFA1-F7A0-4802-B54F-19C00A66EE27.png" width="410"><br>先来看下主线程的<code>po CFRunLoopGetCurrent()</code>，整理以后如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoop</span><br><span class="line">&#123; </span><br><span class="line">   wakeup port = <span class="number">0x1e03</span>, stopped = <span class="keyword">false</span>, ignoreWakeUps = <span class="keyword">false</span>, </span><br><span class="line">   current mode = kCFRunLoopDefaultMode,</span><br><span class="line">   common modes = </span><br><span class="line">   &#123;</span><br><span class="line">        UITrackingRunLoopMode <span class="comment">//CFString Mode名称</span></span><br><span class="line">        kCFRunLoopDefaultMode <span class="comment">//CFString</span></span><br><span class="line">   &#125;,</span><br><span class="line">   common mode items = </span><br><span class="line">   &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="number">0</span> : callout = PurpleEventSignalCallback</span><br><span class="line">        <span class="number">1</span> : ...</span><br><span class="line">        <span class="number">2</span> : callout = __handleHIDEventFetcherDrain <span class="comment">//释放HIDEvent对象的callback（source0）</span></span><br><span class="line">        <span class="number">5</span> : ...</span><br><span class="line">        <span class="number">6</span> : callout = _wrapRunLoopWithAutoreleasePoolHandler <span class="comment">//AutoReleasePool最高优先级处理 (observer)</span></span><br><span class="line">        <span class="number">7</span> : callout = _wrapRunLoopWithAutoreleasePoolHandler <span class="comment">//AutoReleasePool最低优先级处理 (observer)</span></span><br><span class="line">        <span class="number">8</span> : callout = _afterCACommitHandler <span class="comment">//监听CATransaction，刷新UI（observer）</span></span><br><span class="line">        <span class="number">9</span> : callout = _beforeCACommitHandler <span class="comment">//监听CATransaction</span></span><br><span class="line">        <span class="number">10</span> : callout = _UIGestureRecognizerUpdateObserver <span class="comment">//手势检测回调</span></span><br><span class="line">        <span class="number">11</span> : callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv </span><br><span class="line">        <span class="number">13</span> : callout = FBSSerialQueueRunLoopSourceHandler <span class="comment">//Front Board Services</span></span><br><span class="line">        <span class="number">16</span> : callout = __handleEventQueue <span class="comment">//用户事件回调</span></span><br><span class="line">        <span class="number">19</span> : ...</span><br><span class="line">        <span class="number">21</span> : callout = _ZL20notify_port_callbackP12__CFMachPortPvlS1_ </span><br><span class="line">        <span class="number">22</span> : callout = PurpleEventCallback</span><br><span class="line">   &#125;,</span><br><span class="line">   modes = </span><br><span class="line">   &#123;</span><br><span class="line">        <span class="number">2</span> : CFRunLoopMode</span><br><span class="line">        &#123;</span><br><span class="line">            name = UITrackingRunLoopMode,</span><br><span class="line">            sources0 = </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="number">0</span> : callout = PurpleEventSignalCallback</span><br><span class="line">                <span class="number">2</span> : callout = FBSSerialQueueRunLoopSourceHandler </span><br><span class="line">                <span class="number">4</span> : callout = __handleEventQueue </span><br><span class="line">                <span class="number">5</span> : callout = __handleHIDEventFetcherDrain</span><br><span class="line">            &#125;,</span><br><span class="line">            sources1 = </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="number">0</span> : callout = _ZL20notify_port_callbackP12__CFMachPortPvlS1_ </span><br><span class="line">                <span class="number">3</span> : ...</span><br><span class="line">                <span class="number">4</span> : ...</span><br><span class="line">                <span class="number">5</span> : callout = PurpleEventCallback</span><br><span class="line">                <span class="number">6</span> : ...</span><br><span class="line">            &#125;,</span><br><span class="line">            observers = ( </span><br><span class="line">                callout = _wrapRunLoopWithAutoreleasePoolHandler,</span><br><span class="line">                callout = _UIGestureRecognizerUpdateObserver,</span><br><span class="line">                callout = _beforeCACommitHandler,</span><br><span class="line">                callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv,</span><br><span class="line">                callout = _afterCACommitHandler,</span><br><span class="line">                callout = _wrapRunLoopWithAutoreleasePoolHandler </span><br><span class="line">            ),</span><br><span class="line">            timers = (null),</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="number">3</span> : CFRunLoopMode</span><br><span class="line">        &#123;</span><br><span class="line">            name = GSEventReceiveRunLoopMode,</span><br><span class="line">            sources0 = </span><br><span class="line">            &#123;</span><br><span class="line">                callout = PurpleEventSignalCallback</span><br><span class="line">            &#125;,</span><br><span class="line">            sources1 = </span><br><span class="line">            &#123;</span><br><span class="line">                callout = PurpleEventCallback</span><br><span class="line">            &#125;,</span><br><span class="line">            observers = (null),</span><br><span class="line">            timers = (null),</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="number">4</span> : CFRunLoopMode </span><br><span class="line">        &#123;</span><br><span class="line">            name = kCFRunLoopDefaultMode,  </span><br><span class="line">            sources0 =  </span><br><span class="line">            &#123;   </span><br><span class="line">                </span><br><span class="line">                <span class="number">0</span> : callout = PurpleEventSignalCallback</span><br><span class="line">                <span class="number">2</span> : callout = FBSSerialQueueRunLoopSourceHandler</span><br><span class="line">                <span class="number">4</span> : callout = __handleEventQueue</span><br><span class="line">                <span class="number">5</span> : callout = __handleHIDEventFetcherDrain</span><br><span class="line">            &#125;,</span><br><span class="line">            sources1 = </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="number">0</span> : callout = _ZL20notify_port_callbackP12__CFMachPortPvlS1_ </span><br><span class="line">                <span class="number">3</span> : ...</span><br><span class="line">                <span class="number">4</span> : ...</span><br><span class="line">                <span class="number">5</span> : callout = PurpleEventCallback</span><br><span class="line">                <span class="number">6</span> : ...</span><br><span class="line">            &#125;,</span><br><span class="line">            observers = (</span><br><span class="line">                callout = _wrapRunLoopWithAutoreleasePoolHandler,</span><br><span class="line">                callout = _UIGestureRecognizerUpdateObserver,</span><br><span class="line">                callout = _beforeCACommitHandler,</span><br><span class="line">                callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv,</span><br><span class="line">                callout = _afterCACommitHandler,</span><br><span class="line">                callout = _wrapRunLoopWithAutoreleasePoolHandler</span><br><span class="line">            ),</span><br><span class="line">            timers = (null),</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="number">5</span> : CFRunLoopMode</span><br><span class="line">        &#123;</span><br><span class="line">            name = UIInitializationRunLoopMode, </span><br><span class="line">            sources0 = </span><br><span class="line">            &#123;</span><br><span class="line">                callout = FBSSerialQueueRunLoopSourceHandler </span><br><span class="line">            &#125;,</span><br><span class="line">            sources1 = (null)</span><br><span class="line">            observers = (</span><br><span class="line">            callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv</span><br><span class="line">            ),</span><br><span class="line">            timers = (null),</span><br><span class="line">            </span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="number">6</span> : CFRunLoopMode </span><br><span class="line">        &#123;</span><br><span class="line">            name = kCFRunLoopCommonModes,</span><br><span class="line">            sources0 = (null),</span><br><span class="line">            sources1 = (null),</span><br><span class="line">            observers = (null),</span><br><span class="line">            timers = (null),</span><br><span class="line">        &#125;,</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>主线程默认创建的CFRunLoop包含了5个Mode类型：</p>
<ul>
<li><code>UITrackingRunLoopMode</code>：该Mode能确保UIScrollView的滚动流畅性，UI滚动时切换到的是这个Mode，而NSTimer是在defaultMode里，存在NSTimer不触发的问题，所以我们才把NSTimer加到commonMode里以后在UITrackingRunLoopMode也会触发timer了。</li>
<li><code>GSEventReceiveRunLoopMode</code>：</li>
<li><code>kCFRunLoopDefaultMode</code>：默认Mode类型，用户事件一般都会被加载在这个Mode的Source0处。</li>
<li><code>UIInitializationRunLoopMode</code>：初始化app时的过渡Mode。</li>
<li><code>kCFRunLoopCommonModes</code>：公共Mode类型，一般情况下是空的。</li>
</ul>
<p>在CommonModeItems里注册了以下可识别的Mode Items:<br><code>Observer类型</code>：<br><code>_wrapRunLoopWithAutoreleasePoolHandler</code>： //AutoReleasePool最高优先级处理 (observer)<br><code>_wrapRunLoopWithAutoreleasePoolHandler</code>： //AutoReleasePool最低优先级处理 (observer)<br>以上2个观察者与内存管理有关。<br><code>_afterCACommitHandler</code>： //监听CATransaction，刷新UI（observer）<br><code>_beforeCACommitHandler</code>： //监听CATransaction<br>以上2个观察者有界面刷新有关。<br><code>_UIGestureRecognizerUpdateObserver</code>： //手势检测回调 (observer)，手势变化时都会被这个观察者捕获。mach_msg_trap状态时也需要被RunLoop唤醒以后处理。</p>
<p><code>Source类型</code>：<br><code>_handleHIDEventFetcherDrain</code>： //释放IOHIDEvent对象的callback（source0)，所以有IOHIDEvent事件的位置（通常是唤醒RunLoop的位置）都会有这个回调方法。<br><code>_handleEventQueue</code>： //用户事件回调(source0)，一般的<code>addTarget: action: forControlEvents:</code>方法都会加在source0，并由<code>_handleEventQueue</code>执行。</p>
<p>再看下事件点击线程6的<code>po CFRunLoopGetCurrent()</code>，整理以后如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoop</span><br><span class="line">&#123;</span><br><span class="line">    wakeup port = <span class="number">0x3403</span>, stopped = <span class="keyword">false</span>, ignoreWakeUps = <span class="keyword">false</span>, </span><br><span class="line">    current mode = kCFRunLoopDefaultMode,</span><br><span class="line">    common modes = </span><br><span class="line">    &#123;  </span><br><span class="line">        contents = <span class="string">"kCFRunLoopDefaultMode"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    common mode items = </span><br><span class="line">    &#123;</span><br><span class="line">        callout = _UIEventFetcherTriggerHandOff</span><br><span class="line">        callout = __IOHIDEventSystemClientAvailabilityCallback </span><br><span class="line">        callout = __IOMIGMachPortPortCallback</span><br><span class="line">        callout = __IOHIDEventSystemClientQueueCallback</span><br><span class="line">    &#125;,</span><br><span class="line">    modes = </span><br><span class="line">    &#123;</span><br><span class="line">        CFRunLoopMode</span><br><span class="line">        &#123;</span><br><span class="line">            name = kCFRunLoopDefaultMode</span><br><span class="line">            sources0 = </span><br><span class="line">            &#123;</span><br><span class="line">                callout = _UIEventFetcherTriggerHandOff <span class="comment">//标记UIEvent事件待处理的回调方法</span></span><br><span class="line">            &#125; ,</span><br><span class="line">            sources1 = </span><br><span class="line">            &#123; </span><br><span class="line">                callout = __IOHIDEventSystemClientQueueCallback <span class="comment">//屏幕触摸事件回调</span></span><br><span class="line">                callout = __IOHIDEventSystemClientAvailabilityCallback <span class="comment">//待研究</span></span><br><span class="line">                callout = __IOMIGMachPortPortCallback <span class="comment">//待研究</span></span><br><span class="line">            &#125;,</span><br><span class="line">            observers = (null),</span><br><span class="line">            timers = (null)，</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后我们在Symbolic BreakPoint中添加一个<code>__IOHIDEventSystemClientQueueCallback</code>和<code>_UIEventFetcherTriggerHandOff</code>断点（该处理需要阅读者自行处理，属于Xcode的配置）。再触摸屏幕时，我们可以看到断点在以下2个堆栈关系图里：<br><img src="http://ipa-download.qiniudn.com/873A4049-C316-44A9-8BE7-14CE03035923.png" width="560"><br><img src="http://ipa-download.qiniudn.com/1F89CF6C-237F-46FC-8E16-34ECDE208F20.png" width="537"><br>流程分析：当app启动默认会启动主线程的RunLoopM(M表示主线程)，它在处理完一些事件以后进入mach_msg_trap状态，同时开启了一个事件处理线程6，在RunLoop6（6表示线程6）的source1添加了监听<code>__IOHIDEventSystemClientQueueCallback</code>方法，source0里添加了<code>_UIEventFetcherTriggerHandOff</code>方法，用户不触摸屏幕时该RunLoop也会进入mach_msg_trap状态。当用户触摸屏幕以后，事件线程6的RunLoop6最先被唤醒后执行source1里的<code>__IOHIDEventSystemClientQueueCallback</code>方法来唤醒主线程的RunLoopM，同时RunLoop6的source0里的<code>_UIEventFetcherTriggerHandOff</code>方法会把主线程的RunLoopM里的source0里的用户事件标记为待处理状态，紧接着唤醒的主线程RunLoopM会处理source0里的用户事件。</p>
<h3 id="performSelector:object:afterDelay:">performSelector:object:afterDelay:</h3><p>performSelector延时系列方法也需要RunLoop处理，在内部会创建一个Timer计时来延时执行，所以RunLoop必须是在运行状态才成处理成功。如果不在主线程，需要开发者启动RunLoop来让方法生效。</p>
<p>参考资料：<br><a href="http://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="external">深入理解RunLoop</a> —ibireme大神的深入专研精神真的令人倾佩。<br><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSRunLoop_Class/index.html#//apple_ref/doc/uid/TP40003725" target="_blank" rel="external">NSRunLoop</a><br><a href="https://en.wikipedia.org/wiki/Event_loop" target="_blank" rel="external">Event Loop</a><br><a href="https://en.wikipedia.org/wiki/Mach_(kernel" target="_blank" rel="external">Mach(kernel)</a>)</p>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2017/02/06/「钻」研iOS 之内存管理2/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">『钻』研iOS 之 内存管理（二）</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>


<div class="share">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">分享到：</span>
		<a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
		<a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>



<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="「钻」研iOS 之深入理解NSRunLoop" data-title="『钻』研iOS 之 深入理解NSRunLoop" data-url="http://yoursite.com/2017/02/12/「钻」研iOS 之深入理解NSRunLoop/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"true"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>




</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2017 DeJohn Dong
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: undefined,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: undefined
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>